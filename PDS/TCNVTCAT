/* We first need rexx in comment if compiled or read from SYSPROC. */
/* REXX - TCNVTCAT : MCNVTCAT replacement in REXX */
/*======================================================================
   TCNVTCAT : User provided version of a previous CBIPO supplied
              MCNVTCAT program to help convert your current master
              catalog to a new SERVERPAC system-replace master catalog.
              Uses the Catalog Search Interface (CSI) and generates
              IDCAMS DEFINE control cards you can run against the new
              master catalog.

              It can later compare the current master catalog against
              the new master catalog and generate IDCAMS control cards
              to bring the new master catalog back in synchronization
              with the current master catalog.
--------------------------------------------------------------------- */

/*====================================================================*/
/* Original Author : Alastair Gray - a_j_gray@hotmail.com
                   (or the e-mail I use to post on TSO-REXX/IBM-MAIN)

   This was an extension of previous work that was initially derived
   from the code found in 'SYS1.SAMPLIB(IGGCSIRX)' and blended with
   what CBIPO supplied MCNVTCAT accomplished.

--------------------------------------------------------------------- */

/*====================================================================*/
/* Changes : dd/mm/yyyy   Who             What                        */
/* 1.0.0   - 10/01/2002 - Alastair Gray - Original version RCATCNVT   */
/* 1.1.0   - 14/01/2002 - Alastair Gray - Rewrite using CLICODE base  */
/* 1.1.1   - 14/01/2002 - Alastair Gray - Modify > 5 item handling    */
/* 1.2.0   - 14/01/2002 - Alastair Gray - Add proper foreground       */
/* 1.2.1   - 15/01/2002 - Alastair Gray - Add PAGESPACE RECAT         */
/* 1.2.2   - 16/01/2002 - Alastair Gray - Add 3590 + extra error msgs */
/* 1.3.0   - 16/01/2002 - Alastair Gray - Add CLUSTER RECAT some attrs*/
/* 1.3.1   - 22/01/2002 - Alastair Gray - In line with CSICODE        */
/* 1.4.0   - 14/02/2002 - Alastair Gray - Added Catalog compare code  */
/* 1.4.1   - 15/02/2002 - Alastair Gray - Couple of minor typos fixed */
/* 1.4.2   - 21/02/2002 - Alastair Gray - Fixed RECAT error           */
/* 1.4.3   - 03/04/2002 - Alastair Gray - Fixed catcomp code          */
/* 1.4.4   - 29/04/2002 - Alastair Gray - Added '?' option            */
/* 1.4.5   - 31/05/2002 - Alastair Gray - Correction to processing    */
/* 1.4.6   - 21/06/2002 - Alastair Gray - Checked work area required  */
/* 1.4.7   - 08/08/2002 - Alastair Gray - Corrected Pagespace process */
/* 1.4.8   - 08/08/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.4.9   - 16/08/2002 - Alastair Gray - Added detail to COMP reports*/
/* 1.4.10  - 13/09/2002 - Alastair Gray - Renamed to RCNVTCAT         */
/* 1.4.11  - 20/09/2002 - Alastair Gray - Modified unexpected error   */
/* 1.4.12  - 20/09/2002 - Alastair Gray - Realigned with CSICODE      */
/* 1.4.13  - 20/09/2002 - Alastair Gray - Fixed 'odd' VSAM recat error*/
/* 1.4.14  - 08/11/2002 - Alastair Gray - Fixed devtype '0000'        */
/* 1.4.15  - 14/11/2002 - Alastair Gray - Changed SYSDA to SYSALLDA   */
/* 1.4.15  - 18/11/2002 - Alastair Gray - Fixed catcomp error new>old */
/* 1.4.16  - 21/11/2002 - Alastair Gray - Changed to BPXWDYN          */
/* 1.5.0   - 21/11/2002 - Alastair Gray - replaced LISTDSI function   */
/* 1.5.1   - 22/11/2002 - Alastair Gray - allowed JES seq output      */
/* 1.5.2   - 30/01/2003 - Alastair Gray - fixed PDS output bug        */
/* 1.5.3   - 03/03/2003 - Alastair Gray - allow for no-OMVS available */
/* 1.5.4   - 04/03/2003 - Alastair Gray - switched OMVS/TSO order     */
/* 1.5.5   - 03/12/2003 - Alastair Gray - Added CSIOPTNS option (Z/OS)*/
/* 1.5.6   - 09/12/2003 - Alastair Gray - Added debug code            */
/* 1.5.7   - 12/12/2003 - Alastair Gray - fixed 1st field offset      */
/* 1.5.8   - 17/12/2003 - Alastair Gray - tweaked arguments           */
/* 1.5.9   - 18/12/2003 - Alastair Gray - added DEBUG(2)              */
/* 1.6.0   - 14/01/2004 - Alastair Gray - Added fullword on/off by OS */
/* 1.6.1   - 26/09/2012 - Alastair Gray - Corrected variable bug      */
/* 1.7.0   - 17/08/2016 - Lionel Dyck   - SWA Above the Line          */
/* 1.7.1   - 16/08/2016 - John McKown   - replace LISTDSI &
                                          make UNIX shell compatible  */
/* ??      - 06/10/2016 - Tom Taylor    - Fixed Substr of csicatnm    */
/* 1.7.2   - 08/11/2016 - Lionel Dyck   - Add TARGET keyword          */
/* 1.81    - 30/08/2017 - "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
             Opinion: No real z/OS System Programmer wanted UNIX
                      shell compatibility that complicated the code.
             1) Using the ISPF vv.mm to identify a levelset.
                Use VER/LEV n to handle bundled changes.
             2) Changed routine DSEXIST to is_dataset_a_catalog to
                better describe what the routine is doing.
             3) Fixed error ROUTINE NOT FOUND on OUTTRAP under
                is_dataset_a_catalog when RCNVTCAS uses PGM=IRXJCL.
             4) Removed errant comment claiming the REPORT will always
                be dynamically allocated.
             5) Removed 'obsolete' changed routines.
             6) Removed empty comments to improve phase-1 performance.
                And removed gobs of trailing comment blank space.
                Eliminated some redundant comments that stated nothing
                more than what the REXX code had.
             7) Changed comment boxes to improve phase-1 performance.
             8) Added consistent punctuation to comments.
             9) Personal preference: changed contractions to two words.
             10) Changed /= to be consistent with use of <>.
             11) Removed unused routines:
                 Old LISTDD
                 Older LISTDD
                 SWAREQ
             12) Space permitting, moved DO onto the THEN line so
                 that a THEN by itself implies only the next statement
                 is part of the IF.
                 Moved Then to end of IF.
                 Put DO onto the ELSE.
             13) Removed VSAMREUS as it is unused and claimed to
                 duplicate ATTR1.
             14) Separated the REPORT from the DEFINES control cards.
             15) Added a DO to Otherwise for consistency.
             16) Added OMVS(USS) allocate of DEFINES separate from
                 REPORT. Better blocking factor, too.
             17) Added Returns where they were missing or I
                 accidentally deleted them.
             18) REPORT: Added the missing printer control for what was
                 LRECL=133 (now 137 because I went to VBA).
--------------------------------------------------------------------- */
/* 1.82    - 19/01/2018 - "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
             1) Fixed the dynamic allocation of REPORT when not run
                from the sample JCL RCNVTCA$.
--------------------------------------------------------------------- */
/* 1.83    - 25/01/2018 - "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
             1) Renamed to TCNVTCAT for TSO-Only.
             2) The 'REPORT' no longer uses VBA 137 and is placed in the
                same PDS as the DEFINE statements as member $REPORT.
             3) Removed the unused sms_flag code.
             4) Shift code to be more efficient, e.g. check allocations
                and argument values before initializing variables.
               a) Moved DD checking earlier in the processing.
               b) Moved DD allocation earlier in the processing.
               c) Moved argument checking earlier in the processing.
             5) Issue return code > 0 when things are not right.
             6) Documented CSIOPTNS uses 'F' to avoid the 65,535
                limitation listed below.
             7) cat.1 was being blanked out, causing the current
                system master catalog to be used regardless of what
                'old' catalog name was passed in as an argument.
                Commented out cat.1 = ' '
             8) Removed DEBUG code.
             9) Added PANEL(TCNVTCAP) when FOREGROUND ISPF enabled.
             10) Reduced REPORT to 80 columns.
             11) Removed SYSCTLG from the report.
             12) Removed bogus cat variable from the CATALOG operand.
             13) Changed 2LQ to TCNVTCAT.
--------------------------------------------------------------------- */
/* 1.84    - 25/01/2018 - "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
             1) Removed label FINISH.
             2) Added progress display to the COMPCAT routine.
--------------------------------------------------------------------- */
/* 1.85    - 26/01/2018 - "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
             1) Indentation and stylized using the Programming Using
                The Kenneth Tomiak Method (PUTKTM).
             2) Create member $JCL with sample IDCAMS JCL.
             3) If mcatold not passed then default to current system.
--------------------------------------------------------------------- */
/* 1.86    - 27/02/2018 - "Kenneth Tomiak"<CBT_Ken@KTomiak.BIZ>
             1) Included the Find_Hostdsn() routine. This version
                uses QBASELIB to get the data set name.
--------------------------------------------------------------------- */

/*======================================================================
   Notes :

   1. This program writes out various error messages, the return and
      reason codes can be checked using those found listed for the
      IBM message IDC3009I. The module is the CSI internal reference
      and probably is not of much use to anyone outside IBM.

   2. Two return codes are 'special':
      RC=100, Reason=4
      RC=44 , Reason=14

      This relates to entries of greater than 65,535 characters.
      If you get these special RCs, then you need to enable fullword
      processing by changing the value of CSIOPTNS to 'F' from ' '.

      Kenneth Tomiak writes:
      CSIOPTNS was added in change 1.5.5   - 03/12/2003.
      Only those running on a pre OS/390 R10 system would be affected
      as the code defaults to 'F' when MVSVAR('sysmvs') positions 3,5,7
      are greater than '609'.

--------------------------------------------------------------------- */

/*====================================================================
   So how does this differ from the original MCNVTCAT ?

   1. Well it's written in REXX and uses the Catalog Search Interface.

   2. It does not check the actual devices available on the system
      So you may get a catalog entry for a non-present device type.

   3. It does not add bits of LISTCAT messages into the report totals
      or the generated members.

   4. It DOES handle datasets cataloged on more than five volume !
      So does not write out an error message for that condition.

   5. I am pretty sure that it does not handle SYSCTLG properly. As
      the manual states that OS CVOLs do not work after 01/01/2000 I
      guess this should not be an issue for many out there.

   6. It writes its report to the $REPORT member of the PDS rather
      than to a SYSOUT.

   7. It generates a RECAT member that contains statements to allow
      the RECATALOG of PAGESPACE and SYS1.** datasets.

      Currently this only supports VSAM clusters with the following
      non-default attributes : LINEAR, REUSE

   8. It can be used to compare two catalogs and produces reports
      showing the differences between the catalogs.

  ====================================================================*/

  PARSE UPPER Arg all_arguments       /* Get passed arguments */
  my_rc = Initialization_routine()
  IF (my_rc = 0) THEN my_rc = Process_routine()
  my_rc = Termination_routine()
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine initializes constants and variables.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Initialization_routine:
  return_code = 0
  PARSE VERSION,
    version_rexx_name,       /* REXX370 */
    version_rexx_version,    /* 3.48 */
    version_rexx_date        /* 01 May 1992 */
  PARSE SOURCE,
    source_host_env,         /* TSO */
    source_call_type,        /* COMMAND */
    source_uc_exec_name,     /* GENIE */
    source_hostdd,           /* SYSEXEC */
    source_hostdsn,          /* ? */
    source_nf_exec_name,     /* ? */
    source_initial_cmd_env,  /* TSO */
    source_asid_name,        /* ISPF */
    source_char8_user_token, /* ? */
    source_hostother         /* "" */
  TSO_flag = ''
  env_flag = ''
  ispf_flag = ''
  r_cnt = 0
  IF (ADDRESS() = 'TSO') THEN DO       /* test IF under TSO */
    x = Msg('Off')                     /* Disable messages */
    x = Prompt('Off')                  /* Disable prompts */
    TSO_flag = 'TSO'                   /* set TSO flag */
    IF (SYSVAR("SYSENV") = 'FORE') THEN DO /* test for foreground */
      env_flag = 'FORE'                 /* set ENV flag */
    END
    IF (SYSVAR("SYSISPF") = 'ACTIVE') THEN DO /* test for ISPF */
      ispf_flag = 'ISPF'                /* set ISPF flag */
      function_rc = ispf_enable()
    END
  END
  ELSE DO
    SAY "This simplified version of RCNVTCAT only runs under TSO."
    return_code = 16
    return return_code
  END

/*====================================================================
   Call internal routine to discover DDNAMEs and their data sets.
======================================================================*/
  function_rc = get_listalc()     /* This only needs to be done once! */

/*====================================================================
   Check IF //DEFINES is allocated. IF not, allocate a new data set.
======================================================================*/
  rcnvtcat_defines_dsn = ddname_allocated_check("DEFINES")
  IF (rcnvtcat_defines_dsn = "UNDEFINED") THEN DO
    llq = random(100000)
    IF (SYSVAR("SYSPREF") <> SYSVAR("SYSUID")) THEN DO
      SAY SYSVAR("SYSPREF") "<>" SYSVAR("SYSUID")
      rcnvtcat_defines_dsn = SYSVAR("SYSPREF")".TCNVTCAT.DEFINES.T"llq
    END
    ELSE DO
      rcnvtcat_defines_dsn = SYSVAR("SYSUID")".TCNVTCAT.DEFINES.T"llq
    END
    function_rc = SYSDSN("'"rcnvtcat_defines_dsn"'")
    IF (function_rc = "OK") THEN DO
      r_cnt = r_cnt + 1
      r_text = "'"rcnvtcat_defines_dsn"' exists, deleting it."
      ADDRESS TSO "DELETE '"rcnvtcat_defines_dsn"'"
      delete_rc = RC
      IF (delete_rc <> 0) THEN DO
        r_cnt = r_cnt + 1
        r_text.r_cnt = "DELETE of '"rcnvtcat_defines_dsn"'" ,
          "failed, RC("delete_rc")"
        r_cnt = r_cnt + 1
        r_text.r_cnt = "Unable to continue."
        function_rc = show_report_text()
        return_code = 16
        return return_code
      END
    END
    ADDRESS TSO "ALLOC FILE(DEFINES) DA('"rcnvtcat_defines_dsn"')" ,
      "UNIT(SYSALLDA) TRACKS SPACE(5,15) DIR(5)" ,
      "RECFM(F B) BLKSIZE(0) LRECL(80) NEW CATALOG"
    alloc_rc = RC
    IF (alloc_rc <> 0) THEN DO
      r_cnt = r_cnt + 1
      r_text.r_cnt = "Allocation of the PDS for '"rcnvtcat_defines_dsn"'" ,
        "failed, RC("alloc_rc")"
      r_cnt = r_cnt + 1
      r_text.r_cnt = "Unable to continue."
      function_rc = show_report_text()
        return_code = 16
        return return_code
    END
  END

/*====================================================================
   Handle passed parameters.
======================================================================*/

/* ------------------------------------- *
   Check for TARGET(newcatalog) keyword:
   - not found THEN done here
   - found THEN extract
     - save target catalog name
     - remove from parameters
 * ------------------------------------- */
  mcattgt = ''                         /* set target catalog to null */
  IF POS("TARGET(",all_arguments) > 0 THEN DO
    PARSE VAR all_arguments val_left "TARGET("mcattgt")" val_right
    all_arguments = val_left val_right
    IF left(mcattgt,1) = "'" THEN DO
       PARSE VAR mcattgt "'" mcattgt "'" .
    END
  END

  argnum = 0
  cat. = ''
  DO i = 1 to Words(all_arguments)     /* loop thru arguments */
    testarg = STRIP(Word(all_arguments,i),B,"'") /* remove apostrophes */
    argnum = argnum + 1
    cat.argnum = testarg
  END
  SELECT
    WHEN (argnum = 0) THEN DO
      IF (env_flag = 'FORE') & ,
         (ispf_flag = 'ISPF') THEN DO
        function_rc = prompt_for_mcat()
        IF (function_rc = 0) THEN DO
          ZERRALRM = "YES"
          ZERRHM = "*"
          ZERRSM = 'Abort accepted'
          ZERRLM = 'User aborted processing.'
          ADDRESS ISPEXEC "SETMSG MSG(ISRZ002)"
          return_code = 16
          return return_code
        END
      END
      ELSE DO
        r_cnt = r_cnt + 1
        r_text.r_cnt = '**(cat)** No entry provided for catalog name.'
        r_cnt = r_cnt + 1
        r_text.r_cnt = '**(cat)** Defaulting to current system.'
        function_rc = show_report_text()
        outtrap_rc = OUTTRAP(cat_out.)
        ADDRESS TSO "LISTCAT ENTRY('"SYSVAR("SYSUID")"')"
        outtrap_rc = OUTTRAP("OFF")
        DO ox = 1 to cat_out.0
          IF (POS("IN-CAT --- ",cat_out.ox) > 0) THEN DO
            PARSE VAR cat_out.ox . "IN-CAT --- " mcatold
            mcatold = STRIP(mcatold,"B"," ")
            Leave
          END
        END
        cat.1 = mcatold
        process = 'RCNVTCAT'               /* process as normal RCNVTCAT */
        IF (mcattgt = '') THEN mcattgt = mcatold
      END
    END
    WHEN (argnum = 1) THEN DO           /* only one catalog */
      process = 'RCNVTCAT'               /* process as normal RCNVTCAT */
      IF (mcattgt = "") THEN mcattgt = cat.1
    END
    WHEN (argnum = 2) THEN DO           /* WHEN two catalogs THEN */
      process = 'CATCOMP'                /* process for Catalog compare */
      IF (mcattgt = "") THEN mcattgt = cat.2
    END
    Otherwise DO                        /* two catalogs */
      r_cnt = r_cnt + 1
      r_text.r_cnt = '**(cat)** Too many arguments - retry.'
      r_cnt = r_cnt + 1
      r_text.r_cnt = "I fear I might misinterpret what you meant to do."
      r_cnt = r_cnt + 1
      r_text.r_cnt = "Unable to continue."
      function_rc = show_report_text()
      return_code = 16
      return return_code
    END
  END
  IF (is_dataset_a_catalog("'"cat.1"'") > 4) THEN DO
    SAY '**(cat)** Bad entry provided for catalog name.'
    SAY '**(cat)** 'cat.1
    SAY '**(cat)** LISTCAT ENTRY Return code = 'sysreason
    SAY '**(cat)** 'sysmsglvl1
    SAY '**(cat)** 'sysmsglvl2
    return_code = 16
    return return_code
  END
  ELSE DO
    mcatold = cat.1
  END
  IF (process = 'CATCOMP') &,
     (is_dataset_a_catalog("'"cat.2"'") > 4) THEN DO
    SAY '**(cat)** Bad entry provided for second catalog name.'
    SAY '**(cat)** 'cat.2
    SAY '**(cat)** LISTCAT ENTRY Return code = 'sysreason
    SAY '**(cat)** 'sysmsglvl1
    SAY '**(cat)** 'sysmsglvl2
    return_code = 16
    return return_code
  END
  IF (cat.2 <> "") & ,
     (is_dataset_a_catalog("'"cat.2"'") = 0) THEN DO
    mcatnew = cat.2
  END
  IF (mcattgt = "") THEN mcattgt = mcatold

/*====================================================================*/
/* Initialise the various totals variables */
/*====================================================================*/
  l_cnt   = 0                     /* Initialise output line count */
  ali_tot = 0                     /* Total Aliases */
  anv_tot = 0                     /* Total Aliases NONVSAM */
  axx_tot = 0                     /* interim alias total */
  avu_tot = 0                     /* Total Aliases VSAM UCAT */
  gdg_tot = 0                     /* Total GDGs */
  msc_tot = 0                     /* Total MISC datasets */
  nvd_tot = 0                     /* Total NONVSAM datasets */
  nvo_tot = 0                     /* Total NONVSAM (not SYS1) dsns */
  nvv_tot = 0                     /* Total NONVSAM dsn volumes */
  sy1_tot = 0                     /* Total NONVSAM SYS1 datasets */
  uct_tot = 0                     /* Total Usercatalog imports */
  ivd_tot = 0                     /* Total invalid devices */

  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does the processing.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Process_routine:
  flt = '**'                           /* Set the filter */
  typ = ' '                            /* Set entry types required */
  ct1 = ' '                            /* Set for 1 catalog only */
  bcp = MVSVAR('sysmvs')
  lev = SUBSTR(bcp,3,1)||SUBSTR(bcp,5,1)||SUBSTR(bcp,7,1)
  IF (lev > 609) THEN DO            /* os/390 R10 and up for fullword*/
    csioptns = SUBSTR('F',1,1)         /* 'F'for fullword */
  END
  ELSE DO
    csioptns = SUBSTR(' ',1,1)         /* ' 'for halfword */
  END
  IF (process = 'RCNVTCAT') THEN DO
    count.id = 0                       /* initialise count */
    member = 'ALIAS'                   /* processing ALIAS */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    x = CSI_routine(cat.1,'**','X','Y') /* Call CSI */
    Call WRITE_MEMBER                  /* write-out member */
    member = 'NONVSAM'                 /* processing NONVSAM */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    x = CSI_routine(cat.1,'**','AH','Y') /* Call CSI */
    Call WRITE_MEMBER                  /* write-out member */
    member = 'SYS1'                    /* processing SYS1 */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    x = CSI_routine(cat.1,'SYS1.**','AH','Y') /* Call CSI */
    Call WRITE_MEMBER                  /* write-out member */
    member = 'IMPORT'                  /* processing IMPORT */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    x = CSI_routine(cat.1,'**','U','Y') /* Call CSI */
    Call WRITE_MEMBER                  /* write-out member */
    member = 'GDG'                     /* processing GDG */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    x = CSI_routine(cat.1,'**','B','Y') /* Call CSI */
    Call WRITE_MEMBER                  /* write-out member */
    member = 'MISC'                    /* processing MISC */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    x = CSI_routine(cat.1,'**','CGR','Y') /* Call CSI */
    Call WRITE_MEMBER                  /* write-out member */
    member = 'RECAT'                   /* processing RECAT (MISC+) */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    x = CSI_routine(cat.1,'**','CGR','Y') /* Call CSI */
    Call WRITE_MEMBER                  /* write-out member */
    member = '$REPORT'                 /* processing REPORT */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    Call build_statistics_report       /* generate report */
    Call WRITE_REPORT                  /* write out report */
    j.1  = "//*"
    j.2  = "//* Uncomment the control cards you want to process."
    j.3  = "//*"
    j.4  = "//* The GDG base needs to be defined before entries."
    j.5  = "//* Import usercatalogs before defining ALIAS entries."
    j.6  = "//*"
    j.7  = "//DEFINES EXEC PGM=IDCAMS"
    j.8  = "//SYSIN     DD *"
    j.9  = "  /* Generated:" Date() Time() "*/"
    j.10 = "/*"
    j.11 = "//*         DD DISP=SHR,DSN="rcnvtcat_defines_dsn"(IMPORT)"
    j.12 = "//*         DD DISP=SHR,DSN="rcnvtcat_defines_dsn"(ALIAS)"
    j.13 = "//*         DD DISP=SHR,DSN="rcnvtcat_defines_dsn"(GDG)"
    j.14 = "//*         DD DISP=SHR,DSN="rcnvtcat_defines_dsn"(SYS1)"
    j.15 = "//*         DD DISP=SHR,DSN="rcnvtcat_defines_dsn"(NONVSAM)"
    j.16 = "//SYSPRINT  DD SYSOUT=*"
    j.17 = "//*"
    j.18 = "//* End of job $JCL."
    j.19 = "//"
    j.0 = 19
    Call WRITE_JCL                     /* write out JCL    */
  END
  ELSE DO                              /* Process as Catalog compare */
    id = 'OLD'                         /* specify for 'old' catalog */
    count.id = 0                       /* initialise count */
    cat.old = cat.1                    /* retain catalog name */
    x = CSI_routine(cat.1,flt,' ','Y') /* Call CSI procedure */
    id = 'NEW'                         /* specify for 'NEW' catalog */
    count.id = 0                       /* initialise count */
    cat.new = cat.2                    /* retain catalog name */
    x = CSI_routine(cat.2,flt,' ','Y') /* Call CSI procedure */
    member = 'COMPFULL'                /* processing FULL comparison */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    Call COMP_REPORT                   /* Build the report */
    Call WRITE_MEMBER                  /* write the member */
    member = 'COMPSHRT'                /* processing SHORT comparison */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    Call COMP_REPORT                   /* Build the report */
    Call WRITE_MEMBER                  /* write the member */
    member = 'EXTRA'                   /* processing EXTRA member */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    Call NEW_EXT                       /* Build the report */
    Call WRITE_MEMBER                  /* write the member */
    member = 'CHANGED'                 /* processing CHANGED member */
    IF (env_flag = "FORE") & (ispf_flag = "ISPF") THEN DO
      ADDRESS ISPEXEC "CONTROL DISPLAY LOCK"
      message = "Processing" member "entries"
      ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    END
    Call OLD_BAD                       /* Build the report */
    Call WRITE_MEMBER                  /* write the member */
    Call build_statistics_report       /* generate report */
    Call WRITE_report                  /* write the report */
    j.1  = "//*"
    j.2  = "//* Uncomment the control cards you want to process."
    j.3  = "//*"
    j.4  = "//DEFINES EXEC PGM=IDCAMS"
    j.5  = "//SYSIN     DD *"
    j.6  = "  /* Generated:" Date() Time() "*/"
    j.7  = "/*"
    j.8  = "//*         DD DISP=SHR,DSN="rcnvtcat_defines_dsn"(CHANGED)"
    j.9  = "//SYSPRINT  DD SYSOUT=*"
    j.10 = "//*"
    j.11 = "//* End of job $JCL."
    j.12 = "//"
    j.0 = 12
    Call WRITE_JCL                     /* write out JCL    */
  END
/*====================================================================*/
/* Display output IF foreground ISPF */
/*====================================================================*/
  IF (env_flag = 'FORE') &,
     (ispf_flag = 'ISPF') THEN DO
    ADDRESS ISPEXEC "VIEW DATASET('"rcnvtcat_defines_dsn"($REPORT)')"
  END
  return return_code

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
=======================================================================
 This routine does any pre-termination cleanup.
=======================================================================
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
Termination_routine:
  IF (libdef_plib = 1) THEN DO
    ADDRESS ISPEXEC "LIBDEF ISPPLIB DATASET"
  END
  return 0

/*====================================================================*/
/* Use LISTALC ST to discover allocated DDNAMEs and their data sets.  */
/*====================================================================*/
get_listalc:
  rc = Outtrap("ln.")                 /* open trap                  */
  "LISTALC STATUS"
  rc = Outtrap("OFF")                 /* close trap                 */
  dd_names = 0
  dd_nnbr. = 0
  DO trapx = 2 to ln.0                  /* skip heading         */
    ln.trapx = space(ln.trapx)
    PARSE VAR ln.trapx tempname tempddnm
    SELECT
      WHEN (tempddnm <> " ") THEN DO
        PARSE VAR ln.trapx fullname tiotddnm
        dd_names = dd_names + 1       /* DDName index         */
        dd_name.dd_names = tiotddnm
        dd_nnbr.tiotddnm = dd_names
        dsname.dd_names.0 = 0
        ds_temp = dsname.dd_names.0 + 1
        dsname.dd_names.0 = ds_temp
        dsname.dd_names.ds_temp = fullname
      END
      WHEN ((left(ln.trapx,3) <> " ") &,
            (Words(ln.trapx) = 1)) THEN DO
        PARSE VAR ln.trapx fullname .
        trapx = trapx + 1
        ln.trapx = space(ln.trapx)
        PARSE VAR ln.trapx tempddnm " " final_disp " " .
        IF ((tempddnm <> " ") &,
            (final_disp <> " ")) THEN DO
          tiotddnm = tempddnm
          dd_names = dd_names + 1   /* DDName index         */
          dd_name.dd_names = tiotddnm
          dd_nnbr.tiotddnm = dd_names
          dsname.dd_names.0 = 0
        END
        ds_temp = dsname.dd_names.0 + 1
        dsname.dd_names.0 = ds_temp
        dsname.dd_names.ds_temp = fullname
      END
      Otherwise DO
        SAY "*ERR*" ln.trapx
      END
    END
  END                                 /* trapx                      */
  return dd_names

/*====================================================================*/
/* ddname_allocated_check - Discover DSNAME of DDNAME.                */
/*====================================================================*/
ddname_allocated_check:
  PARSE arg match_dd
  match_dsn = "UNDEFINED"
  dd# = dd_nnbr.match_dd
  IF (dd# > 0) THEN DO
    dn= dd_name.dd#
    nd = dsname.dd#.0
    match_dsn = ""
    DO ds# = 1 to nd
      IF (nd > 1) THEN DO
        match_dsn = match_dsn""dsname.dd#.ds#";"
      END
      ELSE DO
        match_dsn = dsname.dd#.ds#
      END
    END
  END
  return match_dsn

/*====================================================================*/
/* Show report text WHEN no DEFINES pds exists.                       */
/*====================================================================*/
show_report_text:
  DO rx = 1 to r_cnt
    SAY r_text.rx
  END
  return 0

/*====================================================================*/
/* ISPF is available so enable ISPPLIB and give a better user interfce*/
/*====================================================================*/
ispf_enable:
  IF (source_hostdsn = "?") THEN DO
    function_rc = find_hostdsn()
  END
  listdsi_rc = Listdsi("'"source_hostdsn"'")
  vdef_volser = SYSVOLUME
  vdef_unit = SYSUNIT
  libdef_plib = 0
  ADDRESS ISPEXEC "LIBDEF ISPPLIB DATASET",
    "ID('"source_hostdsn"') STACK"
  libdef_rc = RC
  IF (libdef_rc <> 0) THEN DO
    ZERRLM = "LIBDEF of ISPPLIB failed, rc="libdef_rc
    msg_rc = 1
    return_code = libdef_rc
  END
  libdef_plib = 1
  return 0

/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
 Search a DD to find where this code runs from.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
find_hostdsn:
  Address ISPEXEC ,
    "QBASELIB" source_hostdd "ID(DSNLIST)"
  ISPEXEC_rc = RC
  If (ISPEXEC_rc <> 0) Then Do
    msg_rc = 1
    ZERRLM = "QBASELIB Failed, RC("ISPEXEC_rc")"
    Return 4
  End
  dsnlist_temp = dsnlist
  @trap_state = TRAPMSG("On")
  msg_state = Msg("OFF")
  Do While dsnlist_temp <> ""
    Parse Var dsnlist_temp one_dsn "," dsnlist_temp
    one_dsn = Strip(one_dsn,"B","'")
    sysdsn_rc = SysDsn("'"one_dsn"("source_uc_exec_name")'")
    If (sysdsn_rc = "OK") Then Do
      source_hostdsn = STRIP(one_dsn,"B"," ")
      Leave
    End
  End
  msg_rc = Msg(msg_state)
  @trap_rc = TRAPMSG(@trap_state)
  Return 0

/*====================================================================*/
/* No mcat provided, prompt with a panel.                      */
/*====================================================================*/
prompt_for_mcat:
  outtrap_rc = OUTTRAP(cat_out.)
  ADDRESS TSO "LISTCAT ENTRY('"SYSVAR("SYSUID")"')"
  outtrap_rc = OUTTRAP("OFF")
  DO ox = 1 to cat_out.0
    IF (POS("IN-CAT --- ",cat_out.ox) > 0) THEN DO
      PARSE VAR cat_out.ox . "IN-CAT --- " mcatold
      mcatold = STRIP(mcatold,"B"," ")
      Leave
    END
  END
  IF (mcattgt = '') THEN mcattgt = mcatold
  mcatdef = rcnvtcat_defines_dsn
  message = "Enter command CANCEL to abort processing."
  redisplay = 1
  DO while redisplay = 1
    ADDRESS ISPEXEC "DISPLAY PANEL(TCNVTCAP)"
    SELECT
      WHEN (translate(zcmd) = "CANCEL") THEN DO
        redisplay = 0
      END
      otherwise DO
        redisplay = 0
        cat.1 = mcatold
        argnum = 1
        IF (mcatnew <> "") THEN DO
          argnum = argnum + 1
          cat.2 = mcatnew
        END
      END
    END
  END
  IF (argnum = 1) THEN process = 'RCNVTCAT'
  else process = 'CATCOMP'
  return argnum

/*====================================================================*/
/* WRITE_JCL - Write out the generated lines to JCL.                  */
/*====================================================================*/
WRITE_JCL:
  IF (TSO_flag = 'TSO') THEN DO
   ADDRESS TSO "Alloc Fi(JCL)" ,
    "Da('"rcnvtcat_defines_dsn"($JCL)') Shr Reuse"
   alloc_rc = RC
   IF (alloc_rc <> 0) THEN DO
     SAY "Write_JCL TSO ALLOC, RC("alloc_rc")."
   END
  END
  ADDRESS MVS "ExecIO "j.0" DiskW JCL (Stem j. FINIS)"
  ADDRESS TSO "Free Fi(JCL)"
  Return

/*====================================================================*/
/* WRITE_REPORT - Write out the generated lines to REPORT.            */
/*====================================================================*/
WRITE_REPORT:
  IF (r.0 = 0) THEN DO               /* IF no output */
    r_cnt = 1                          /* write a no output line */
    l.r_cnt = ' /* no data produced */'
  END
  IF (TSO_flag = 'TSO') THEN DO
   ADDRESS TSO "Alloc Fi(REPORT)" ,
    "Da('"rcnvtcat_defines_dsn"($REPORT)') Shr Reuse"
   alloc_rc = RC
   IF (alloc_rc <> 0) THEN DO
     SAY "Write_REPORT TSO ALLOC, RC("alloc_rc")."
   END
  END
  ADDRESS MVS "ExecIO "r.0" DiskW REPORT (Stem r. FINIS)"
  ADDRESS TSO "Free Fi(REPORT)"
  Return

/*====================================================================*/
/* WRITE_MEMBER - Write out the generated lines to member.            */
/*====================================================================*/
WRITE_MEMBER:
  IF (l_cnt = 0) THEN DO               /* IF no output */
    l_cnt = l_cnt + 1                  /* write a no output line */
    l.l_cnt = ' /* no data produced */'
  END
  ADDRESS TSO "Alloc Fi("member")" ,
    "Da('"rcnvtcat_defines_dsn"("member")') Shr Reuse"
  alloc_rc = RC
  IF (alloc_rc <> 0) THEN DO
    SAY "Write_Member TSO ALLOC, RC("alloc_rc") on" member"."
    return 4
  END
  c_cnt = 1                          /*  add a line */
  c.c_cnt = ' /*' member '*/'          /*  add member name */
  ADDRESS MVS "ExecIO "c_cnt" DiskW" member "(Stem c.)"
  ADDRESS MVS "ExecIO "l_cnt" DiskW" member "(Stem l. FINIS)"
  ADDRESS TSO "Free Fi("member")"
  l_cnt = 0                            /* re-init line count for next */
  Return

/*====================================================================*/
/* CSI Processing section */
/*====================================================================*/
/*====================================================================
  Execute the Catalog Search Interface
======================================================================*/
CSI_routine:
  Arg cat,flt,typ,ct1
  modrsnrc = SUBSTR(' ',1,4)           /* clear module/return/reason */
  csifiltk = SUBSTR(flt,1,44)          /* move filter key into list */
  csicatnm = SUBSTR(cat,1,44)          /* clear catalog name */
  csiresnm = SUBSTR(' ',1,44)          /* clear resume name */
  csidtyps = SUBSTR(typ,1,16)          /* clear entry types */
  csicldi  = SUBSTR('Y',1,1)           /* indicate data and index */
  csiresum = SUBSTR(' ',1,1)           /* clear resume flag */
  csis1cat = SUBSTR(ct1,1,1)           /* indicate search > 1 catalogs */
/*====================================================================*/
/* Initialize requested fields */
/*====================================================================*/
  csinumen = '000D'X                   /* init number of fields = 13 */
  csifld01 = Left('ENTYPE  ',8)        /* type of entry */
  csifld02 = Left('ENTNAME ',8)        /* name of entry */
  csifld03 = Left('TYPE    ',8)        /* type of associated entry */
  csifld04 = Left('NAME    ',8)        /* name of associated entry */
  csifld05 = Left('GDGLIMIT',8)        /* GDG Limit */
  csifld06 = Left('GDGATTR ',8)        /* GDG Attributes */
  csifld07 = Left('DSCRDT2 ',8)        /* Dataset creation date */
  csifld08 = Left('ATTR1   ',8)        /* Attributes */
  csifld09 = Left('CATTR   ',8)        /* Attributes page and swap */
  csifld10 = Left('DEVTYP  ',8)        /* UCB Device type */
  csifld11 = Left('VOLSER  ',8)        /* Volume serial number */
  csifld12 = Left('FILESEQ ',8)        /* File Sequence number */
  csifld13 = Left('VSAMTYPE',8)        /* VSAM dataset information */
/*====================================================================*/
/* Build the selection criteria fields part of parameter list */
/*====================================================================*/
  csiopts  = csicldi ||csiresum||csis1cat||csioptns
  csifield = csifiltk||csicatnm||csiresnm||csidtyps||csiopts ||csinumen
  csifield = csifield||csifld01||csifld02||csifld03||csifld04||csifld05
  csifield = csifield||csifld06||csifld07||csifld08||csifld09||csifld10
  csifield = csifield||csifld11||csifld12||csifld13||csifld14
/* Initialise and build work are output part of parameter list */
  csiusrln = 1048575                   /* CSIUSRLN work area length */
                                     /* range from 1024 to 1048575 */
                                     /* was 524288 before 1.81     */
  dwork = Right(D2c(csiusrln),4,'00'X)||Copies('00'X,csiusrln-4)
/* Change csiresum for subsequent invocations. */
  csiresum = 'Y'
/* Set up loop for resume (if a resume is necessary). */
/* Issue link to CSI - Catalog Search Interface */
  Do While csiresum = 'Y'
    ADDRESS LinkPGM 'IGGCSI00 modrsnrc csifield dwork'
    r15 = rc                         /* get returned code */
    mod = SUBSTR(modrsnrc,1,2)       /* get module code */
    res = C2d(SUBSTR(modrsnrc,3,1))  /* get return code */
    ret = C2d(SUBSTR(modrsnrc,4,1))  /* get reason code */
    IF (r15 > 0) THEN DO             /* WHEN error occured */
      SAY '**(Error-1)* CSI processing.'
      SAY '**(Error-2)* R15='r15 'Module='mod' Return='ret' Reason='res
      Leave
    END
/*====================================================================*/
    csiresum = SUBSTR(csifield,150,1) /* Get resume flag for next loop */
    csiresnm = SUBSTR(csifield,89,44) /* Get resume name for next loop */
    csiusrln = C2D(SUBSTR(dwork,1,4)) /* Get length of work area */
    csireqln = C2D(SUBSTR(dwork,5,4)) /* Get length of work area reqd */
    csiusdln = C2D(SUBSTR(dwork,9,4)) /* Get length of work area used */
    IF (csireqln > csiusrln) THEN DO
      SAY '**(Error-1)* Work Area defined  = 'csiusrln
      SAY '**(Error-2)* Work Area used     = 'csiusdln
      SAY '**(Error-3)* Work Area required = 'csireqln
      SAY '**(Error-4)* Increase the work area defined - CSIUSRLN.'
    END
    IF (csiusdln < 65) THEN Leave    /* No entries returned */
    off = 15                         /* Starting position */
/*====================================================================*/
/*   Process data returned in work area */
/*====================================================================*/
    DO While off < csiusdln          /* DO until all data is processed*/
      csi_flag = SUBSTR(dwork,off,1) /* get the flag byte */
      csi_type = SUBSTR(dwork,off+1,1) /* get the entry type */
      csi_name = SUBSTR(dwork,off+2,44) /* get the entry name */
      csi_retn = SUBSTR(dwork,off+46,4) /* get the return code */
      mod = SUBSTR(csi_retn,1,2)     /* get CSI module */
      res = C2d(SUBSTR(csi_retn,3,1)) /* get reason code */
      ret = C2d(SUBSTR(csi_retn,4,1)) /* get return code */
      IF (csi_type = '0') THEN DO    /* Catalog entry */
        IF (ret > 0) THEN DO         /* test catalog return code */
          SAY '**(Error-1)* Catalog processing - 'STRIP(csi_name,B)'.'
          SAY '**(Error-2)* Module='mod' Return='ret' Reason='res
        END
        csicname = csi_name          /* set the catalog name */
        plus = 50                    /* length for catalog entry */
      END
      ELSE DO
        csiename = csi_name          /* use the entry name */
        csietype = csi_type          /* use the entry name */
        csieflag = X2b(C2x(csi_flag)) /* use the entry flag */
        csienter = SUBSTR(csieflag,2,1) /* get the entry error flag */
        csiedata = SUBSTR(csieflag,3,1) /* get the data indication flag */
        SELECT
          WHEN (csienter = '1') THEN DO
            SAY '**(Error-1)* Entry processing - 'STRIP(csi_name,B)'.'
            SAY '**(Error-2)* Module='mod' Return='ret' Reason='res
            plus = 50                 /* length for error entry */
          END
          WHEN (csiedata = '0') THEN DO
            SAY '**(Error-1)* Entry processing - 'STRIP(csi_name,B)'.'
            SAY '**(Error-2)* No data returned'
            SAY '**(Error-3)* Module='mod' Return='ret' Reason='res
            plus = 50                 /* length for error entry */
          END
          Otherwise DO
            IF (csioptns = 'F') THEN  /* check IF fullword requested */
              csitotln = C2d(SUBSTR(csi_retn,1,4))/* get entry total length */
            Else                      /* otherwise (default halfword) */
              csitotln = C2d(SUBSTR(csi_retn,1,2))/* get entry total length */
            Call ENTRY                /* Execute entry processing */
            plus = 46 + csitotln      /* length for normal entry */
          END
        END
       END
       Call DATA_HANDLING
       off = off + plus            /* build new offset for next entry */
    END
  END
  Return 0

/*====================================================================*/
/* Get offsets and lengths of next field */
/*====================================================================*/
get_next_field:
  IF (csioptns = 'F') THEN DO          /* check IF fullword requested */
    e_off = off + 46                   /* get offset to entries */
    o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset */
    l_fld.1 = C2d(SUBSTR(dwork,e_off+8,4)) /* get first field length */
    e_pos = 12                         /* set offset of second field */
    DO flds = 2 to C2d(csinumen)       /* loop through other fields */
     prv = flds - 1                    /* set 'previous' value */
     o_fld.flds = o_fld.prv + l_fld.prv/* get next offset */
     l_fld.flds = C2d(SUBSTR(dwork,e_off+e_pos,4)) /* get next length */
     e_pos = e_pos + 4
    END
  END
  ELSE DO                              /* otherwise (default halfword) */
    e_off = off + 46                   /* get offset to entries */
    o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset */
    l_fld.1 = C2d(SUBSTR(dwork,e_off+4,2)) /* get first field length */
    e_pos = 6                          /* set offset of second field */
    DO flds = 2 to C2d(csinumen)       /* loop through other fields */
     prv = flds - 1                    /* set 'previous' value */
     o_fld.flds = o_fld.prv + l_fld.prv/* get next offset */
     l_fld.flds = C2d(SUBSTR(dwork,e_off+e_pos,2)) /* get next length */
     e_pos = e_pos + 2
    END
  END
  return 0

/*====================================================================*/
/* Process entry fields to extract data */
/*====================================================================*/
ENTRY:                               /* Start entry processing      ##*/
  IF (csioptns = 'F') THEN DO          /* check IF fullword requested */
    e_off = off + 46                   /* get offset to entries */
    o_fld.1 = e_off+8+(C2d(csinumen)*4)/* get first field offset */
    l_fld.1 = C2d(SUBSTR(dwork,e_off+8,4)) /* get first field length */
    e_pos = 12                         /* set offset of second field */
    DO flds = 2 to C2d(csinumen)       /* loop through other fields */
     prv = flds - 1                    /* set 'previous' value */
     o_fld.flds = o_fld.prv + l_fld.prv/* get next offset */
     l_fld.flds = C2d(SUBSTR(dwork,e_off+e_pos,4)) /* get next length */
     e_pos = e_pos + 4
    END
  END
  ELSE DO                              /* otherwise (default halfword) */
    e_off = off + 46                   /* get offset to entries */
    o_fld.1 = e_off+4+(C2d(csinumen)*2)/* get first field offset */
    l_fld.1 = C2d(SUBSTR(dwork,e_off+4,2)) /* get first field length */
    e_pos = 6                          /* set offset of second field */
    DO flds = 2 to C2d(csinumen)       /* loop through other fields */
     prv = flds - 1                    /* set 'previous' value */
     o_fld.flds = o_fld.prv + l_fld.prv/* get next offset */
     l_fld.flds = C2d(SUBSTR(dwork,e_off+e_pos,2)) /* get next length */
     e_pos = e_pos + 2
    END
  END
  entype   = SUBSTR(dwork,o_fld.1,l_fld.1)   /* Type of entry */
  entname  = SUBSTR(dwork,o_fld.2,l_fld.2)   /* Name of entry */
  type     = SUBSTR(dwork,o_fld.3,l_fld.3)   /* Type of assc entry */
  name     = SUBSTR(dwork,o_fld.4,l_fld.4)   /* Name of assc entry */
  gdglimit = SUBSTR(dwork,o_fld.5,l_fld.5)   /* GDG limit */
  gdgattr  = SUBSTR(dwork,o_fld.6,l_fld.6)   /* GDG attributes */
  dscrdt2  = SUBSTR(dwork,o_fld.7,l_fld.7)   /* dataset creation date */
  attr1    = SUBSTR(dwork,o_fld.8,l_fld.8)   /* attributes */
  cattr    = SUBSTR(dwork,o_fld.9,l_fld.9)   /* attribs page and swap */
  devtyp   = SUBSTR(dwork,o_fld.10,l_fld.10) /* device type */
  volser   = SUBSTR(dwork,o_fld.11,l_fld.11) /* volume serial */
  fileseq  = SUBSTR(dwork,o_fld.12,l_fld.12) /* file sequence */
  vsamtype = SUBSTR(dwork,o_fld.13,l_fld.13) /* VSAM dataset information*/
  vsam_attr = ''                           /* initialise vsam attributes*/
  IF (Index(csifield,'ENTYPE') > 0) THEN Call FLD_ENTYPE
  IF (Index(csifield,'ENTNAME') > 0) THEN Call FLD_ENTNAME
  IF (Index(csifield,'GDGLIMIT') > 0) THEN Call FLD_GDGLIMIT
  IF (Index(csifield,'GDGATTR') > 0) THEN Call FLD_GDGATTR
  IF (Index(csifield,'DSCRDT2') > 0) THEN Call FLD_DSCRDT2
  IF (Index(csifield,'ATTR1') > 0) THEN Call FLD_ATTR1
  IF (Index(csifield,'CATTR') > 0) THEN Call FLD_CATTR
  IF (Index(csifield,'DEVTYP') > 0) THEN Call FLD_DEVTYP
  IF (Index(csifield,'VOLSER') > 0) THEN Call FLD_VOLSER
  IF (Index(csifield,'FILESEQ') > 0) THEN Call FLD_FILESEQ
  IF (Index(csifield,'VSAMTYPE') > 0) THEN Call FLD_VSAMTYPE
  Return

/*====================================================================*/
/* FLD_ENTYPE   - Process ENTYPE   field */
/*====================================================================*/
FLD_ENTYPE:
  SELECT                               /* decode type flag */
    WHEN (entype = 'C') THEN entype = 'CLUSTER'
    WHEN (entype = 'D') THEN entype = 'DATA'
    WHEN (entype = 'I') THEN entype = 'INDEX'
    WHEN (entype = 'A') THEN entype = 'NONVSAM'
    WHEN (entype = 'H') THEN entype = 'GDS'
    WHEN (entype = 'B') THEN entype = 'GDG'
    WHEN (entype = 'R') THEN entype = 'PATH'
    WHEN (entype = 'G') THEN entype = 'AIX'
    WHEN (entype = 'X') THEN entype = 'ALIAS'
    WHEN (entype = 'U') THEN entype = 'UCAT'
    Otherwise DO
      SAY '**(Error-1)* Entry type processing for 'STRIP(entname,T)
      SAY '**(Error-2)* Entry type ='entype' X=<'C2x(entype)'>'
      entype = ' '                       /* unknown type */
    END
  END
  Return

/*====================================================================*/
/* FLD_ENTNAME  - Process ENTNAME  field */
/*====================================================================*/
FLD_ENTNAME:
  IF (SUBSTR(entname,1,2) = '0000'x) THEN DO /* IF null dsname */
    entname = Left(C2x(entname),44)     /* Return hex value */
  END
  Return

/*====================================================================*/
/* FLD_GDGLIMIT - Process GDGLIMIT field */
/*====================================================================*/
FLD_GDGLIMIT:
  gdglimit = X2d(C2x(gdglimit))  /* return decimal number */
  Return

/*====================================================================*/
/* FLD_GDGATTR  - Process GDGATTR  field */
/*====================================================================*/
FLD_GDGATTR:
  gdgattr = X2b(C2x(gdgattr))
  IF (SUBSTR(gdgattr,1,1) = '1') THEN DO
    gdg_emp = 'EMPTY'
  END
  ELSE DO
    gdg_emp = 'NOEMPTY'
  END
  IF (SUBSTR(gdgattr,2,1) = '1') THEN DO
    gdg_scr = 'SCRATCH'
  END
  ELSE DO
    gdg_scr = 'NOSCRATCH'
  END
  Return

/*====================================================================*/
/* FLD_DSCRDT2  - Process DSCRDT2  field */
/*====================================================================*/
FLD_DSCRDT2:
  IF (SUBSTR(dscrdt2,1,2) <> 'FFFF'X) THEN DO
    yyddd = C2x(SUBSTR(dscrdt2,1,3))
    yy    = SUBSTR(yyddd,1,2)
    ddd   = SUBSTR(yyddd,3,3)
    cent  = C2x(SUBSTR(dscrdt2,4,1))
    IF (cent = '00') THEN DO
      yyyy    = yy + 1900
    END
    ELSE DO
      yyyy    = yy + 2000
    END
    IF (yyyy = '1900') THEN DO         /* correct for '00' */
      yyyy = '2000'
    END
    savcrdt2 = dscrdt2
    dscrdt2 = yyyy'.'ddd
  END
  Return

/*====================================================================*/
/* FLD_ATTR1    - Process ATTR1    field */
/*====================================================================*/
FLD_ATTR1:
  attr1 = X2b(c2x(attr1))
  IF (SUBSTR(attr1,1,1) = '1') THEN DO
    vsam_attr = vsam_attr' SPEED'
  END
  IF (SUBSTR(attr1,3,1) = '1') THEN DO
    vsam_attr = vsam_attr' REUSE'
  END
  IF (SUBSTR(attr1,4,1) = '1') THEN DO
    vsam_attr = vsam_attr' ERASE'
  END
  Return

/*====================================================================*/
/* FLD_CATTR    - Process CATTR    field */
/*====================================================================*/
FLD_CATTR:
  cattr = X2b(C2x(cattr))
  IF (entype = 'CLUSTER') THEN DO
    IF (SUBSTR(cattr,8,1) = '1') THEN DO
      entype = 'PAGESPACE'
    END
    IF (SUBSTR(cattr,7,1) = '1') THEN DO
      pageswap = 'SWAP'
    END
    ELSE DO
      pageswap = 'NOSWAP'
    END
  END
  Return

/*====================================================================*/
/* FLD_DEVTYP   - Process DEVTYP   field to translate data */
/*====================================================================*/
FLD_DEVTYP:
  devices = ''                         /* initialise devices */
  DO d_pos = 1 to Length(devtyp) By 4  /* loop thru devtyp field */
    device = SUBSTR(devtyp,d_pos,4)  /* get device (UCB) */
    d_model = SUBSTR(device,1,1)     /* get model byte */
    d_option = SUBSTR(device,2,1)    /* get option byte */
    d_class = SUBSTR(device,3,1)     /* get class byte */
    d_device = SUBSTR(device,4,1)    /* get device byte */
    SELECT
      WHEN (d_class = '80'x) THEN DO
        dev_class = 'TAPE'            /* Tape device */
        SELECT
          WHEN (d_device = '03'x) THEN dev_type = '3400' /* 3400/3420-3/5/7*/
          WHEN (d_device = '04'x) THEN dev_type = '3420' /* 3420-4/6/8 */
          WHEN (d_device = '05'x) THEN dev_type = '3410'
          WHEN (d_device = '06'x) THEN dev_type = '8809'
          WHEN (d_device = '07'x) THEN dev_type = '3430'
          WHEN (d_device = '08'x) THEN dev_type = '7340'
          WHEN (d_device = '09'x) THEN dev_type = '9374'
          WHEN (d_device = '80'x) THEN dev_type = '3480'
          WHEN (d_device = '81'x) THEN dev_type = '3490'
          WHEN (d_device = '83'x) THEN dev_type = '3590'
          WHEN (device = '00000000'x) THEN dev_type = '0000'
          Otherwise DO
            dev_type = C2x(device)   /* show UCB IF unknown */
            SAY '**(Error-1)* Device type processing for 'STRIP(entname,T)
            SAY '**(Error-2)* Device type = 'dev_type
          END
        END
      END
      WHEN (d_class = '20'x) THEN DO
        dev_class = 'DASD'            /* DASD device */
        SELECT
          WHEN (d_device = '04'x) THEN dev_type = '9345'
          WHEN (d_device = '09'x) THEN dev_type = '3330'
          WHEN (d_device = '0A'x) THEN dev_type = '3340'
          WHEN (d_device = '0B'x) THEN dev_type = '3350'
          WHEN (d_device = '0C'x) THEN dev_type = '3375'
          WHEN (d_device = '0D'x) THEN dev_type = '3330' /* 3330-11 */
          WHEN (d_device = '0E'x) THEN dev_type = '3380'
          WHEN (d_device = '0F'x) THEN dev_type = '3390'
          WHEN (device = '00000000'x) THEN dev_type = '0000'
          Otherwise DO
            dev_type = C2x(device)    /* show UCB IF unknown */
            SAY '**(Error-1)* Device type processing for 'STRIP(entname,T)
            SAY '**(Error-2)* Device type = 'dev_type
          END
        END
      END
      Otherwise DO
        dev_class = 'UNKN'            /* Unknown device */
        SELECT
          WHEN (device = '00000000'x) THEN dev_type = '0000'
          Otherwise DO
            dev_type = C2x(device)      /* show UCB IF unknown */
            SAY '**(Error-1)* Device type processing for 'STRIP(entname,T)
            SAY '**(Error-2)* Device type = 'dev_type
          END
        END
      END
    END
    devices = devices||' '||Left(dev_type,8) /* build device list */
  END
  devices = STRIP(devices,B,' ')       /* clean up device list */
  Return

/*====================================================================*/
/* FLD_VOLSER   - Process VOLSER   field */
/*====================================================================*/
FLD_VOLSER:
  volsers = ''
  DO v_pos = 1 To Length(volser) By 6
    volume = SUBSTR(volser,v_pos,6)
    IF (SUBSTR(volume,1,2) = '00'x) THEN DO
      volume = '000000'
    END
    volume = Right(STRIP(volume,B),6)' '
    volsers = volsers||'  '||volume
  END
  volser = STRIP(volsers,B)
  Return

/*====================================================================*/
/* FLD_FILESEQ  - Process FILESEQ  field */
/*====================================================================*/
FLD_FILESEQ:
  build = ''
  DO f_pos = 1 To Length(fileseq) By 2
    build = build||Right(X2d(C2x(SUBSTR(fileseq,f_pos,2))),8)||' '
  END
  fileseq = build
  Return

/*====================================================================*/
/* FLD_VSAMTYPE - Process VSAMTYPE field */
/*====================================================================*/
FLD_VSAMTYPE:
  vsam_byte1 = X2b(C2x(SUBSTR(vsamtype,1,1))) /* get byte 1 */
  vsam_byte2 = X2b(C2x(SUBSTR(vsamtype,2,1))) /* get byte 2 */
  SELECT
    WHEN (SUBSTR(vsam_byte1,1,1) = '1') THEN DO
      vsam_type = 'KSDS'
      vsam_attr = vsam_attr' INDEXED'
    END
    WHEN (SUBSTR(vsam_byte1,7,1) = '1') THEN DO
      vsam_type = 'RRDS'
      vsam_attr = vsam_attr' NUMBERED'
    END
    WHEN (SUBSTR(vsam_byte2,6,1) = '1') THEN DO
      vsam_type = 'LDS'
      vsam_attr = vsam_attr' LINEAR'
    END
    WHEN (SUBSTR(vsam_byte2,8,1) = '1') THEN DO
      vsam_type = 'VRRDS'
      vsam_attr = vsam_attr' NUMBERED'
    END
    Otherwise DO
      vsam_type = 'ESDS'
      IF (entype <> 'INDEX') THEN DO
        vsam_attr = vsam_attr' NONINDEXED'
      END
    END
  END
  IF (SUBSTR(vsam_byte1,2,1) = '1') THEN DO
    vsam_attr = vsam_attr' WRITECHECK'
  END
  IF (SUBSTR(vsam_byte1,3,1) = '1') THEN DO
    vsam_attr = vsam_attr' IMBED'
  END
  IF (SUBSTR(vsam_byte1,4,1) = '1') THEN DO
    vsam_attr = vsam_attr' REPLICATE'
  END
  IF (entype <> 'INDEX') THEN DO
    IF (SUBSTR(vsam_byte1,8,1) = '1') THEN DO
      vsam_attr = vsam_attr' SPANNED'
    END
  END
  IF (SUBSTR(vsam_byte2,2,1) = '1') THEN DO /* undocumented VVDS indicator */
    vsam_vvds = 'Y'                     /* Set VVDS flag */
  END
  ELSE DO
    vsam_vvds = 'N'                     /* Set VVDS flag off */
  END
  vsam_attr = STRIP(vsam_attr,B)
  Return

/*====================================================================*/
/* DO a LISCAT ENTRY to ensure the dsn is a catalog. */
/*====================================================================*/
is_dataset_a_catalog: Procedure Expose sysreason sysmsglvl1 sysmsglvl2
  PARSE arg indsn
  sysreason=0
  sysmsglvl1=' Not Emulated '
  sysmsglvl2=' Not Emulated '
  IF indsn = '' THEN DO
    sysreason=29
    return 16
  END
  ignore_listcat. = ""
  ignore_listcat.0 = 0
  Call OutTrap "ignore_listcat."
  ADDRESS TSO "LISTCAT ENT("indsn")"
  lrc=rc
  sysreason=rc
  hexrc=right(d2x(rc),8,"0")
  Call outtrap "OFF"
  drop ignore_listcat.
  IF "0438" = left(hexrc,4) THEN DO
    sysreason=24
    Return 16
  END
  return lrc

/*====================================================================*/
/* DATA_HANDLING - Carry out whatever processing is required ... */
/*====================================================================*/
DATA_HANDLING:
  IF (csi_type <> '0') THEN DO         /* Catalog entries */
    IF (process = 'CATCOMP') THEN DO /* Catalog compare code */
      count.id         = count.id+1  /* increment count */
      val              = count.id    /* save value */
      entname.id.val   = entname     /* store entry name */
      entype.id.val    = entype      /* store entry type */
      name.id.val      = name        /* store assoc name */
      type.id.val      = type        /* store assoc type */
      pageswap.id.val  = pageswap    /* store pageswap */
      devices.id.val   = devices     /* store devices */
      fils.id.val      = fils        /* store fils */
      gdg_emp.id.val   = gdg_emp     /* store gdg_emp */
      gdg_scr.id.val   = gdg_scr     /* store gdg_scr */
      gdglimit.id.val  = gdglimit    /* store gdglimit */
      vsam_attr.id.val = vsam_attr   /* store vsam_attr */
      vsam_type.id.val = vsam_type   /* store vsam_attr */
      vsam_vvds.id.val = vsam_vvds   /* store vsam_vvds */
      volsers.id.val   = volsers     /* store volsers by value */
      volsers.id.entname = volsers   /* store volsers by entry name */
      name.id.entname  = name        /* store name by entry name */
      val.id.entname   = val         /* store value by entry name */
    END                               /** END Catalog compare code    **/
    ELSE DO
      SELECT
        WHEN (member = 'MISC') THEN Call MEM_MISC
        WHEN (member = 'RECAT') THEN Call MEM_RECAT
        WHEN (member = 'ALIAS') THEN Call MEM_ALIAS
        WHEN (member = 'GDG') THEN Call MEM_GDG
        WHEN (member = 'IMPORT') THEN Call MEM_IMPORT
        WHEN (member = 'NONVSAM') THEN DO /* NONVSAM member */
          axx_tot = anv_tot          /* set intermim alias total */
          nvd_tot = nvd_tot + 1      /* increment total non-vsam */
          nvv_tot = nvv_tot + Words(volser) /* calc non-vsam vols */
          IF (SUBSTR(entname,1,4) <> 'SYS1') THEN DO /* not SYS1 */
            nvo_tot = nvo_tot + 1    /* increment non-vsam only total */
            Call MEM_NONVSAM
          END
          anv_tot = axx_tot          /* set non-vsam aliases total */
        END
        WHEN (member = 'SYS1') THEN DO /* SYS1 member */
          sy1_tot = sy1_tot + 1      /* increment sys1 total */
          Call MEM_NONVSAM
        END
        Otherwise DO
          NOP
        END
      END
    END
  END
  Return

/*====================================================================*/
/* MEM_MISC - Generate MISC member lines */
/*====================================================================*/
MEM_MISC:
  IF (entype = 'CLUSTER') |,
     (entype = 'PAGESPACE') THEN DO
    msc_tot = msc_tot + 1
    l_cnt = l_cnt + 1
    text = ' /* 'Left(entype' ',15,'-')
    text = text' 'Left(entname,32)'  NOT PROCESSED */'
    l.l_cnt = text
  END
  Return

/*====================================================================*/
/* MEM_RECAT - Generate RECAT member lines */
/*====================================================================*/
MEM_RECAT:
  IF (entype = 'PAGESPACE') THEN DO
    page_name     = entname
    page_swap     = pageswap
    IF (Index(type,'D') <> 0) THEN DO
      data_flag = 'DATA'
    END
    ELSE DO
      data_flag = ''
    END
  END
  IF (entype = 'CLUSTER') THEN DO
    IF (SUBSTR(entname,1,4) <> 'SYS1') THEN DO
      cluster_name  = entname
      l_cnt = l_cnt + 1
      text = ' /* 'Left(entype' ',15,'-')
      text = text' 'Left(entname,34)' CANNOT RECAT */'
      data_flag = ''
      index_flag = ''
      l.l_cnt = text
    END
    ELSE DO
      cluster_name  = entname
      IF (Index(type,'D') <> 0) THEN DO
        data_flag = 'DATA'
      END
      ELSE DO
        data_flag = ''
      END
      IF (Index(type,'I') <> 0) THEN DO
        index_flag = 'INDEX'
      END
      ELSE DO
        index_flag = ''
      END
      cluster_bits  = type
    END
  END
  IF (entype = 'DATA') &,
     (data_flag = 'DATA') THEN DO
    SELECT
      WHEN (vsam_vvds = 'Y') THEN DO          /* use VVDS flag */
        l_cnt = l_cnt + 1
        text = ' /* 'Left('VVDS ',15,'-')
        text = text' 'Left(cluster_name,32)'  NOT PROCESSED */'
        l.l_cnt = text
      END
      WHEN (Index(name,page_name) > 0) THEN DO
        l_cnt = l_cnt + 1
        page_name = STRIP(page_name,"T"," ")
        l.l_cnt = '   DEF PAGESPACE(NAME('page_name') -'
        l_cnt = l_cnt + 1
        volser = STRIP(volser,"T"," ")
        l.l_cnt = '          VOL('volser') -'
        l_cnt = l_cnt + 1
        page_swap = STRIP(page_swap,"T"," ")
        l.l_cnt = '          'page_swap' -'
        l_cnt = l_cnt + 1
        l.l_cnt = '          RECATALOG ) -'
        l_cnt = l_cnt + 1
             l.l_cnt = '          CAT('mcattgt')'
      END
      WHEN (Index(name,cluster_name) > 0) THEN DO
        l_cnt = l_cnt + 1
        cluster_name = STRIP(cluster_name,"T"," ")
        l.l_cnt = '   DEF CLUSTER(NAME('cluster_name') -'
        l_cnt = l_cnt + 1
        volser = STRIP(volser,"T"," ")
        l.l_cnt = '          VOL(  'volser') -'
        IF (vsam_attr <> '') THEN DO
          l_cnt = l_cnt + 1
          l.l_cnt = '          'Left(vsam_attr,57)' -'
        END
        l_cnt = l_cnt + 1
        l.l_cnt = '          RECATALOG ) -'
        l_cnt = l_cnt + 1
        entname = STRIP(entname,"T"," ")
        l.l_cnt = '         DATA(NAME('entname')) -'
        IF (index_flag = '') THEN DO
          l_cnt = l_cnt + 1
          l.l_cnt = '          CAT('mcattgt')'
        END
      END
      Otherwise DO
       SAY '**(Error--1)* Unexpected condition for :'
       SAY '**(Error--2)* cluster_name = 'STRIP(cluster_name,T)
       SAY '**(Error--3)* page_name    = 'STRIP(page_name,T)
       SAY '**(Error--4)* entname      = 'STRIP(entname,T)
       SAY '**(Error--5)* entype       = 'STRIP(entype,T)
       SAY '**(Error--6)* name         = 'STRIP(name,T)
       SAY '**(Error--7)* type         = 'STRIP(type,T)
       SAY '**(Error--8)* data_flag    = 'STRIP(data_flag,T)
       SAY '**(Error--9)* index_flag   = 'STRIP(index_flag,T)
       SAY '**(Error-10)* vsam_byte1   = 'vsam_byte1
       SAY '**(Error-11)* vsam_byte2   = 'vsam_byte2
      END
    END
  END
  IF (entype = 'INDEX') &,
     (index_flag = 'INDEX') THEN DO
    l_cnt = l_cnt + 1
    entname = STRIP(entname,"T"," ")
    l.l_cnt = '         INDEX(NAME('entname')) -'
    l_cnt = l_cnt + 1
    l.l_cnt = '          CAT('mcattgt')'
  END
  Return

/*====================================================================*/
/* MEM_ALIAS - Generate ALIAS member lines */
/*====================================================================*/
MEM_ALIAS:
  ali_tot = ali_tot + 1
  l_cnt = l_cnt + 1
  entname = STRIP(entname,"T"," ")
  l.l_cnt = '     DEF ALIAS(NAME('entname') -'
  l_cnt = l_cnt + 1
  name = STRIP(name,"T"," ")
  l.l_cnt = '          REL('name')) -'
  l_cnt = l_cnt + 1
  l.l_cnt = '          CAT('mcattgt')'
  Return

/*====================================================================*/
/* MEM_IMPORT - Generate IMPORT member lines */
/*====================================================================*/
MEM_IMPORT:
  uct_tot = uct_tot + 1
  l_cnt = l_cnt + 1
  entname = STRIP(entname,"T"," ")
  l.l_cnt = '    IMPORT OBJ( ('entname'  -'
  l_cnt = l_cnt + 1
  devices = STRIP(devices,"T"," ")
  l.l_cnt = '          DEVT('devices') VOL('volser')))' ,
    'CONNECT -'
  l_cnt = l_cnt + 1
  l.l_cnt = '          CAT('mcattgt')'
  Call ASSOC_ENTRY
  Return

/*====================================================================*/
/* MEM_GDG - Generate GDG member lines */
/*====================================================================*/
MEM_GDG:
  gdg_tot = gdg_tot + 1
  l_cnt = l_cnt + 1
  entname = STRIP(entname,"T"," ")
  l.l_cnt = '   DEF GDG (NAME('entname') -'
  l_cnt = l_cnt + 1
  gdg_scr = STRIP(gdg_scr,"T"," ")
  gdg_emp = STRIP(gdg_emp,"T"," ")
  l.l_cnt = '          LIMIT('STRIP(gdglimit,"B"," ")')' ,
    gdg_scr gdg_emp') -'
  l_cnt = l_cnt + 1
  l.l_cnt = '          CAT('mcattgt')'
  Return

/*====================================================================*/
/* MEM_NONVSAM - Generate NONVSAM member lines */
/*====================================================================*/
MEM_NONVSAM:
  l_cnt = l_cnt + 1
  entname = STRIP(entname,"T"," ")
  l.l_cnt = '   DEF NVSAM(NAME('entname') -'
  IF (Words(devices) <= 5) THEN DO     /* < 5 devices for dataset */
    l_cnt = l_cnt + 1
    devices = STRIP(devices,"T"," ")
    l.l_cnt = '          DEVT('devices') -'
    IF (dev_class = 'TAPE') &,         /* IF devices is tape */
       (fileseq <> '0') THEN DO        /* IF fileseq number exist */
      l_cnt = l_cnt + 1
      fileseq = STRIP(fileseq,"T"," ")
      l.l_cnt = '          FSEQN('fileseq') -'
    END
    l_cnt = l_cnt + 1
    volser = STRIP(volser,"T"," ")
    l.l_cnt = '          VOL('volser'))-'
  END
  ELSE DO                              /* > 5 devices for dataset */
    item_lead = 'DEVT( '               /* devices header */
    item_end  = ') -'                  /* devices trailer */
    item_pad  = ''                     /* no padding */
    items = devices                    /* pass data */
    Call PLUS5_HANDLE                  /* handle > 5 items */
    IF (dev_class = 'TAPE') &,         /* IF devices is tape */
       (fileseq <> '0') THEN DO        /* IF fileseq number exist */
      item_lead = 'FSEQN('             /* fileseq header */
      item_end  = ') -'                /* fileseq trailer */
      item_pad  = Left(' ',7)           /* 7 spaces padding */
      items = fileseq                  /* pass data */
      Call PLUS5_HANDLE                /* handle > 5 items */
    END
    item_lead = 'VOL('               /* volumes header */
    item_end  = ')) -'                /* volumes trailer */
    item_pad  = ''                     /* no padding */
    items = volser                     /* pass data */
    Call PLUS5_HANDLE                  /* handle > 5 items */
  END
  l_cnt = l_cnt + 1
  l.l_cnt = '          CAT('mcattgt')'
  Call ASSOC_ENTRY
  Return

/*====================================================================*/
/* ASSOC_ENTRY - Process associated entries */
/*====================================================================*/
ASSOC_ENTRY:
  DO ali = 1 to Words(name)
    IF (SUBSTR(type,ali,1) = 'X') THEN DO
      axx_tot = axx_tot + 1
      l_cnt = l_cnt + 1
      one_name = STRIP(Word(name,ali),"T"," ")
      l.l_cnt = '     DEF ALIAS(NAME('one_name') -'
      l_cnt = l_cnt + 1
      entname = STRIP(entname,"T"," ")
      l.l_cnt = '          REL('entname')) -'
      l_cnt = l_cnt + 1
      l.l_cnt = '          CAT('mcattgt')'
    END
  END
  Return

/*====================================================================*/
/* PLUS5_HANDLE - Handle more than 5 fields for NONVSAM */
/*====================================================================*/
PLUS5_HANDLE:
  l_cnt = l_cnt + 1
  w_end = Wordindex(items,6)
  data = Left(SUBSTR(items,1,w_end-1),47)
  l.l_cnt = '          'item_lead||data' -'
  DO mult = 6 to Words(items) by 5
    w_sta = Wordindex(items,mult)
    w_end = Wordindex(items,mult+5)
    IF (w_end = 0) THEN DO
      item = SUBSTR(items,w_sta)
    END
    ELSE DO
      item = SUBSTR(items,w_sta,w_end-w_sta)
    END
    l_cnt = l_cnt + 1
    item_length = 47 - Length(item_pad)
    l.l_cnt = '                '||item_pad||Left(item,item_length)' -'
  END
  l.l_cnt = STRIP(l.l_cnt,T,'-')||item_end
  Return

/*====================================================================*/
/* build_statistics_report - Generate REPORT member */
/*====================================================================*/
build_statistics_report:
  tot_tot = ali_tot + uct_tot + nvd_tot + gdg_tot + msc_tot
  sta_tot = tot_tot + ali_tot
  r. = ''
  r.1  = 'TCNVTCAT*  CONVERSION REPORT              '||,
         Date() Time()
  r.2  = 'ICF CATALOG ENTRIES TO BE MIGRATED'
  r.3  = ' '
  r.4  = 'ALIAS   TOTAL .......(M)... 'Right(ali_tot,8)'      '|| ,
         'TOTAL NUMBER OF ALIAS STMTS IN CATALOG'
  r.5  = ' '
  r.6  = ' ALIAS  VSAM UCAT ......... 'Right(avu_tot,8)'      '|| ,
         'ALIAS STMTS ON VSAM USER CATALOGS'
  r.7  = ' ALIAS  NONVSAM DS ........ 'Right(anv_tot,8)'      '|| ,
         'ALIAS STMTS ON NON VSAM DATA SETS'
  r.8  = ''
  r.9  = 'IMPORT  VSAM UCATS ..(M)... 'Right(uct_tot,8)'      '|| ,
         'NUMBER OF VSAM USER CATALOGS'
  r.10 = ''
  r.11 = 'NONVSAM DS TOTAL .......... 'Right(nvd_tot,8)'      '|| ,
         'TOTAL NUMBER OF NON VSAM DATA SETS'
  r.12 = ' NON VSAM VOLUMES ......... 'Right(nvv_tot,8)'      '|| ,
         'VOLUMES ASSOCIATED WITH NON VSAM'
  r.13 = '                                          '|| ,
         'DATA SETS. SEE NOTE 1'
  r.14 = ''
  r.15 = ' NONVSAM SYS1. DS....(M)... 'Right(sy1_tot,8)'      '|| ,
         'SYS1.** NON VSAM DATA SETS'
  r.16 = ' NONVSAM OTHER DS....(M)... 'Right(nvo_tot,8)'      '|| ,
         'ALL OTHER NON VSAM DATA SETS'
  r.17 = ''
  r.18 = 'GDG     TOTAL .......(M)... 'Right(gdg_tot,8)'      '|| ,
         'NUMBER OF GENERATION DATA GROUP STMTS'
  r.19 = ''
  r.20 = 'MISC    TOTAL .......(M)... 'Right(msc_tot,8)'      '|| ,
         'NUMBER OF STATEMENTS WHICH COULD NOT'
  r.21 = '                                          '|| ,
         'BE PROCESSED'
  r.22 = '------------------------------------      '
  r.23 = 'INVALID DEVICE TYPE ....... 'Right(ivd_tot,8)'      '|| ,
         'NUMBER OF STATEMENTS WHICH CONTAIN AN'
  r.24 = '                                          '|| ,
         'INVALID DEVICE TYPE. SEE NOTE 2'
  r.25 = 'NO. OF STMTS PROCESSED .... 'Right(sta_tot,8)'      '|| ,
         'TOTAL NUMBER OF STATEMENTS WHICH WERE'
  r.26 = '                                          '|| ,
         'PROCESSED'
  r.27 = 'SUM OF A/I/N/G/M .......... 'Right(tot_tot,8)'      '|| ,
         'SUM OF STATEMENTS WHICH WERE PROCESSED'
  r.28 = '                                          '|| ,
         'FOR ALIAS/IMPORT/NONVSAM/GDG AND MISC.'
  r.29 = '                                          '|| ,
         'SEE NOTE 3'
  r.30 = ''
  r.31 = '(M)    : A MEMBER WAS CREATED IN DATA SET '|| ,
         rcnvtcat_defines_dsn
  r.32 = 'NOTE 1 : SOME DATA SETS MAY NEED MORE THAN ONE VOLUME '
  r.33 = 'NOTE 2 : DEVICE TYPE IS NOT RECOGNIZED BY RCNVTCAT !!'
  r.34 = '         BETTER CHECK THE CODE !?!'
  r.35 = 'NOTE 3 : DIFFERENCE SHOULD BE THE NUMBER OF ALIAS TOTAL.'
  r.36 = '         THEY ARE PROCESSED TWICE.'
  r.0 = 36
  Return

/*====================================================================*/
/* COMP_REPORT - Produce the Catalog comparison report */
/*====================================================================*/
COMP_REPORT:
  l_cnt = 0
  DO loop = 1 to count.OLD
    entname = entname.OLD.loop
    entype  = entype.OLD.loop
    name    = name.OLD.loop
    volsers = volsers.OLD.loop
    flag.entname = 'Y'
    IF (member = 'COMPFULL') THEN DO
      disp_ent = entname
      disp_entype = Left(entype,8)
    END
    ELSE DO
      disp_ent = Left(entname,36)
      disp_entype = Left(SUBSTR(entype,1,3),4)
    END
    disp_vol = STRIP(volsers,B)
    IF (Symbol('val.NEW.entname') = 'LIT') THEN DO
      l_cnt = l_cnt + 1
      SELECT
        WHEN (entype = 'ALIAS'  ) THEN DO
          detail = STRIP(name.OLD.loop,B)
        END
        WHEN (entype = 'DATA'     ) |,
            (entype = 'INDEX'    ) THEN DO
          detail = STRIP(volsers.old.loop,B)||' ',
                 STRIP(devices.old.loop,B)||' ',
                 STRIP(vsam_type.OLD.loop,B)||' ',
                 STRIP(vsam_attr.OLD.loop,B)
        END
        WHEN (entype = 'NONVSAM'  ) |,
            (entype = 'GDG'      ) |,
            (entype = 'UCAT'     ) |,
            (entype = 'PAGESPACE') THEN DO
          detail = STRIP(volsers.old.loop,B)||' ',
                 STRIP(devices.old.loop,B)
        END
        Otherwise DO
          NOp
        END
      END
      disp_ent = strip(disp_ent,"T"," ")
      l.l_cnt = disp_entype||disp_ent' --missing - 'detail
      status.OLD.loop = 'MISSING'
    END
    ELSE DO
      namenew = name.NEW.entname
      volsnew = volsers.NEW.entname
      SELECT
        WHEN (namenew <> name) THEN DO
          IF (entype = 'ALIAS') THEN DO
            l_cnt = l_cnt + 1
            err_text = ' ##catalog was 'STRIP(name,B)' is 'STRIP(namenew,B)
            l.l_cnt = disp_entype||disp_ent||err_text
            status.OLD.loop = 'BADCAT'
          END
          ELSE DO
            l_cnt = l_cnt + 1
            err_text = ' entries DO not match.'
            l.l_cnt = disp_entype||disp_ent||err_text
            status.OLD.loop = 'BADENT'
          END
        END
        WHEN (volsnew <> volsers) THEN DO
          l_cnt = l_cnt + 1
          err_text = ' ##volser was 'disp_vol' is 'STRIP(volsnew,B)
          l.l_cnt = disp_entype||disp_ent||err_text
          status.OLD.loop = 'BADVOL'
        END
        Otherwise DO
          l_cnt = l_cnt + 1
          l.l_cnt = disp_entype||disp_ent' **entry matches.'
          status.OLD.loop = 'OK'
        END
      END
    END
  END
  DO loop = 1 to count.NEW
    entname = entname.NEW.loop
    entype  = entype.NEW.loop
    volsers = volsers.NEW.loop
    IF (flag.entname <> 'Y') THEN DO
      IF (member = 'COMPFULL') THEN DO
        disp_ent = entname
        disp_entype = Left(entype,8)
      END
      ELSE DO
        disp_ent = Left(entname,36)
        disp_entype = Left(SUBSTR(entype,1,3),4)
      END
      disp_vol = STRIP(volsers,B)
      l_cnt = l_cnt + 1
      l.l_cnt = disp_entype||disp_ent' ++new entry on 'disp_vol
      status.NEW.loop = 'NEW'
    END
  END
  Return

/*====================================================================*/
/* NEW_EXT - Process for new entries */
/*====================================================================*/
NEW_EXT:
  DO loop = 1 to count.NEW
    IF (status.NEW.loop = 'NEW') THEN DO
      entname = entname.NEW.loop
      entype  = entype.NEW.loop
      IF (entype = 'DATA') |,
         (entype = 'INDEX') THEN
       Iterate
      l_cnt = l_cnt + 1
      l.l_cnt = "      /* Entry not present in catalog "cat.old". */"
      l_cnt = l_cnt + 1
      l.l_cnt = "      /* Entry present in catalog     "cat.new". */"
      Call ENTRY_DEL                    /* process an entry delete */
    END
  END
  Return

/*====================================================================*/
/* OLD_BAD - Process for old entries */
/*====================================================================*/
OLD_BAD:
  DO loop = 1 to count.OLD
    entname   = entname.OLD.loop
    entype    = entype.OLD.loop
    volsers   = volsers.OLD.loop
    volser    = STRIP(volsers,B)
    name      = name.OLD.loop
    type      = type.OLD.loop
    pageswap  = pageswap.OLD.loop
    devices   = devices.OLD.loop
    fils      = fils.OLD.loop
    gdg_emp   = gdg_emp.OLD.loop
    gdg_scr   = gdg_scr.OLD.loop
    gdglimit  = gdglimit.OLD.loop
    vsam_attr = vsam_attr.OLD.loop
    vsam_type = vsam_type.OLD.loop
    vsam_vvds = vsam_vvds.OLD.loop
    namenew   = name.NEW.entname
    volsnew   = volsers.NEW.entname
    IF (entype = 'DATA') |,
       (entype = 'INDEX') THEN DO
      Iterate
    END
    SELECT
      WHEN (status.OLD.loop = 'MISSING') THEN DO
        l_cnt = l_cnt + 1
        l.l_cnt = "      /* Entry missing in catalog "cat". */"
      END
      WHEN (status.OLD.loop = 'BADCAT') THEN DO
        l_cnt = l_cnt + 1
        l.l_cnt = "      /* Alias incorrectly pointing to "namenew". */"
      END
      WHEN (status.OLD.loop = 'BADENT') THEN DO
        l_cnt = l_cnt + 1
        l.l_cnt = "      /* Related entries DO not match */"
        l_cnt = l_cnt + 1
        l.l_cnt = "      /* entry "STRIP(entname,T)" */"
        l_cnt = l_cnt + 1
        l.l_cnt = "      /* old "STRIP(name,T)" */"
        l_cnt = l_cnt + 1
        l.l_cnt = "      /* new "STRIP(namenew,T)" */"
      END
      WHEN (status.OLD.loop = 'BADVOL') THEN DO
        l_cnt = l_cnt + 1
        l.l_cnt = "      /* Volume incorrect - was "volsnew". */"
      END
      Otherwise DO
        Iterate
      END
    END
    Call ENTRY_DEL                      /* process an entry delete */
    Call ENTRY_CHG                      /* process an entry change */
  END
  Return

/*====================================================================*/
/* ENTRY_DEL - Create a DELETE statement */
/*====================================================================*/
ENTRY_DEL:
  IF (entype = 'NONVSAM') THEN DO
    tparm = ''
  END
  ELSE DO
    tparm = entype
  END
  l_cnt = l_cnt + 1
  l.l_cnt = "      DELETE "STRIP(entname,T)" "tparm" NOSCRATCH -"
  l_cnt = l_cnt + 1
  l.l_cnt = '          CAT('Left(mcattgt,44)')'
  l_cnt = l_cnt + 1
  l.l_cnt = "      SET MAXCC=0"
  Return

/*====================================================================*/
/* ENTRY_CHG - Create a changed entry statement */
/*====================================================================*/
ENTRY_CHG:
  SELECT
    WHEN (entype = 'NONVSAM') THEN Call MEM_NONVSAM
    WHEN (entype = 'ALIAS') THEN Call MEM_ALIAS
    WHEN (entype = 'GDG') THEN Call MEM_GDG
    Otherwise NOP
  END
  Return

